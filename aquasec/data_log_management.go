package aquasec

import (
	"context"
	"fmt"
	"sort"

	"github.com/aquasecurity/terraform-provider-aquasec/client"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataLogManagement() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataLogManagementRead,
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Description: "The name of the log-management configuration to look up.",
				Computed:    true,
			},
			"enable": {
				Type:        schema.TypeBool,
				Description: "Indicates whether the log-management configuration is enabled (true) or disabled (false).",
				Computed:    true,
			},
			"audit_filter": {
				Type:        schema.TypeString,
				Description: "The audit filter expression applied by the log-management service to narrow down logs.",
				Computed:    true,
			},
			"url": {
				Type:        schema.TypeString,
				Description: "The endpoint URL of the log-management service, where logs are sent or retrieved from.",
				Computed:    true,
			},
			"network": {
				Type:        schema.TypeString,
				Description: "Optional network or connectivity identifier used by the log-management service.",
				Computed:    true,
			},
			"user": {
				Type:        schema.TypeString,
				Description: "Username used for authentication with the log-management service (sensitive).",
				Computed:    true,
				Sensitive:   true,
			},
			"password": {
				Type:        schema.TypeString,
				Description: "Password used for authentication with the log-management service (sensitive).",
				Computed:    true,
				Sensitive:   true,
			},
			"token": {
				Type:        schema.TypeString,
				Description: "Bearer token used for authentication with the log-management service (sensitive).",
				Computed:    true,
				Sensitive:   true,
			},
			"workspace": {
				Type:        schema.TypeString,
				Description: "Workspace or tenant identifier within the log-management service.",
				Computed:    true,
			},
			"key": {
				Type:        schema.TypeString,
				Description: "API key or secret key generated for this log-management configuration (sensitive, may be generated by the service).",
				Computed:    true,
				Sensitive:   true,
			},
			"verify_cert": {
				Type:        schema.TypeBool,
				Description: "Whether SSL/TLS certificate verification is enabled when connecting to the service.",
				Computed:    true,
			},
			"ca_cert": {
				Type:        schema.TypeString,
				Description: "Custom CA certificate used to verify the log-management service’s TLS certificate (sensitive).",
				Computed:    true,
				Sensitive:   true,
			},
			"enable_alphanumeric_sorting": {
				Type:        schema.TypeBool,
				Description: "When enabled, logs are sorted alphanumerically before being processed.",
				Computed:    true,
			},
			"index": {
				Type:        schema.TypeString,
				Description: "Index name or bucket name where the logs are stored or retrieved from in the service.",
				Computed:    true,
			},
			"source": {
				Type:        schema.TypeString,
				Description: "Fixed source identifier used by the log-management service; default set to aquasec.",
				Computed:    true,
			},
			"sourcetype": {
				Type:        schema.TypeString,
				Description: "The type or classification of the log source as recognized by the service.",
				Computed:    true,
			},
			"authentication_option": {
				Type:        schema.TypeString,
				Description: "The authentication method chosen for the service (e.g., API key, OAuth).",
				Computed:    true,
			},
			"projectid": {
				Type:        schema.TypeString,
				Description: "Cloud project or subscription identifier under which logs are collected.",
				Computed:    true,
			},
			"logname": {
				Type:        schema.TypeString,
				Description: "Name of the log stream or log source in the service.",
				Computed:    true,
			},
			"credentials_json": {
				Type:        schema.TypeString,
				Description: "JSON-encoded credentials for service-account style authentication (sensitive).",
				Computed:    true,
				Sensitive:   true,
			},
			"external_id": {
				Type:        schema.TypeString,
				Description: "External identifier used for cross-account or cross-tenant authentication.",
				Computed:    true,
			},
			"role_arn": {
				Type:        schema.TypeString,
				Description: "ARN of the IAM role assumed when interacting with the log-management service.",
				Computed:    true,
			},
			"region": {
				Type:        schema.TypeString,
				Description: "Cloud region identifier where log ingestion or retrieval takes place.",
				Computed:    true,
			},
			"loggroup": {
				Type:        schema.TypeString,
				Description: "Log-group or collection name within the service where logs are grouped.",
				Computed:    true,
			},
			"keyid": {
				Type:        schema.TypeString,
				Description: "Identifier of the key or credential used by the log-management service.",
				Computed:    true,
			},
			"rule": {
				Type:        schema.TypeString,
				Description: "Routing or processing rule name defined for this log-management configuration.",
				Computed:    true,
			},
			"stream_name": {
				Type:        schema.TypeString,
				Description: "Name of the log stream or channel within the service where log events appear.",
				Computed:    true,
			},
			"tenant_id": {
				Type:        schema.TypeString,
				Description: "Tenant or directory ID used in multi-tenant log-management environments.",
				Computed:    true,
			},
			"client_id": {
				Type:        schema.TypeString,
				Description: "Client ID used in OAuth or service-account authentication with the service.",
				Computed:    true,
			},
			"client_secret": {
				Type:        schema.TypeString,
				Description: "Client secret associated with the client ID for authentication (sensitive).",
				Computed:    true,
				Sensitive:   true,
			},
			"cloud": {
				Type:        schema.TypeString,
				Description: "Cloud provider identifier (for example ‘aws’, ‘azure’, ‘gcp’) associated with this log-management configuration.",
				Computed:    true,
			},
			"displayname": {
				Type:        schema.TypeString,
				Description: "Display name for the log management configuration.",
				Computed:    true,
			},
			"hasnewlabel": {
				Type:        schema.TypeBool,
				Description: "Indicates whether the log management configuration has a new label.",
				Computed:    true,
			},
			"learnmore": {
				Type:        schema.TypeString,
				Description: "Link to learn more about the log management configuration.",
				Computed:    true,
			},
			"logo": {
				Type:        schema.TypeString,
				Description: "URL or identifier for the logo associated with the log management configuration.",
				Computed:    true,
			},
			"logofull": {
				Type:        schema.TypeString,
				Description: "Full URL or identifier for the logo associated with the log management configuration.",
				Computed:    true,
			},
			"audit": {
				Type:        schema.TypeString,
				Description: "Audit information for the log management configuration.",
				Computed:    true,
			},
		},
	}
}

func dataLogManagementRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	ac := m.(*client.Client)
	var diags diag.Diagnostics

	logMgmt, err := ac.GetLogManagements()
	if err != nil {
		return diag.FromErr(err)
	}
	if logMgmt == nil || len(*logMgmt) == 0 {
		d.SetId("")
		return diag.Errorf("no log management configurations returned")
	}
	names := make([]string, 0, len(*logMgmt))
	for k := range *logMgmt {
		names = append(names, k)
	}
	sort.Strings(names)

	repIndex := -1
	for i, providerName := range names {
		svc := (*logMgmt)[providerName]
		if svc.Enable {
			repIndex = i
			break
		}
	}
	if repIndex == -1 {
		repIndex = 0
	}
	repName := names[repIndex]
	repSvc := (*logMgmt)[repName]

	set := func(key string, value interface{}) {
		if err := d.Set(key, value); err != nil {
			diags = append(diags, diag.Diagnostic{
				Severity: diag.Error,
				Summary:  "Failed to set field",
				Detail:   fmt.Sprintf("%s: %v", key, err),
			})
		}
	}

	name := repSvc.Name
	if name == "" {
		name = repName
	}

	set("name", name)
	set("enable", repSvc.Enable)
	set("audit_filter", repSvc.AuditFilter)
	set("url", repSvc.URL)
	set("network", repSvc.Network)
	set("user", repSvc.User)
	set("password", repSvc.Password)
	set("token", repSvc.Token)
	set("workspace", repSvc.Workspace)
	set("key", repSvc.Key)
	set("verify_cert", repSvc.VerifyCert)
	set("ca_cert", repSvc.CACert)
	set("enable_alphanumeric_sorting", repSvc.EnableAlphanumericSorting)
	set("index", repSvc.Index)
	set("source", repSvc.Source)
	set("sourcetype", repSvc.SourceType)
	set("authentication_option", repSvc.AuthenticationOption)
	set("projectid", repSvc.ProjectID)
	set("logname", repSvc.LogName)
	set("credentials_json", repSvc.CredentialsJSON)
	set("external_id", repSvc.ExternalID)
	set("role_arn", repSvc.RoleArn)
	set("region", repSvc.Region)
	set("loggroup", repSvc.LogGroup)
	set("keyid", repSvc.KeyID)
	set("rule", repSvc.Rule)
	set("stream_name", repSvc.StreamName)
	set("tenant_id", repSvc.TenantID)
	set("client_id", repSvc.ClientID)
	set("client_secret", repSvc.ClientSecret)
	set("cloud", repSvc.Cloud)
	set("displayname", repSvc.DisplayName)
	set("hasnewlabel", repSvc.HasNewLabel)
	set("learnmore", repSvc.LearnMore)
	set("logo", repSvc.Logo)
	set("logofull", repSvc.LogoFull)
	set("audit", repSvc.Audit)

	if name != "" {
		d.SetId(name)
	} else {
		d.SetId("all")
	}

	return diags
}
